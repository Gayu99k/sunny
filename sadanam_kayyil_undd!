SPRING REST PRACTISE			

			
1.TRIVAINFY

APPLICATION.PROP

server.port=2222
server.sevlet.context-path=/TrivaInfy

SERVICE

public List<HotelDTO> searchHotels(String hotelNameSearchKey) throws TrivaInfyException{

List<Hotel> hotel=hotelRepository.findByHotelNameSearchKey(hotelNameSearchKey);
if(hotel.isEmpty()){
	throw new TrivaInfyException(TrivaInfyConstants.TRIVAINFY_SEARCH_HOTEL_INVALID.toString());
}
List<HotelDTO> hotelDtoList=new ArrayList<>();

if(hotel.getStatus.equals("ACTIVE")){
for(Hotel hotels : hotel){
hotelDtoList.add(HotelDTO.entityTODTOConverter(hotel));
}
}
if(hotelDtoList.isEmpty())
		throw new TrivaInfyException(TrivaInfyConstants.TRIVAINFY_SEARCH_HOTEL_INVALID.toString());

return hotelDtoList;
}

API

@RestController
@Validated
public class api{

@Autowired
TrivaInfyService trivaInfyService;

@GetMapping(value="/hotels/{hotelNameSearch}")
public List<HotelDTO> searchHotels(@PathVariable String hotelNameSearchKey) throws TrivaInfyException{
List<HotelDTO>hotel = trivaInfyService.searchHotels(hotelNameSearchKey.trim());
return hotel;
}

@GetMapping(value="/vendors/{vendorNameSearchKey}")
public List<VendorDTO>searchVendors(@PathVariable String vendorNameSearchKey) throws TrivaInfyException{
List<VendorDTO>vendor = trivaInfyService.searchVendors(vendorNameSearchKey.trim());
return vendor;
}

@PostMapping(value="booking")
public String bookHotel(@Valid @RequestBody BookingDTO bookingDTO) throws TrivaInfyException{
String msg=trivaInfyService.bookHotel(bookingDTO);
return msg;

@PutMapping(value=booking/{bookingId}/{noOfRoomsNew})
public String updateBooking(@Min(value=1 , message="{booking.noofrooms.invalid}" @PathVariable Integer bookingId, 
			    @Min(value=1 , message="{booking.noofrooms.invalid}" @PathVariable Integer noOfRoomsNew) throws TrivaInfyException{

String msg=trivaInfyService.updateBooking(bookingId,noOfRoomsNew);
return msg;
}

@DeleteMapping(value=booking/{bookingId})
public String cancelBooking(@Min(value=1 , message="{booking.noofrooms.invalid}" @PathVariable Integer bookingId) throws TrivaInfyException{

String msg=trivaInfyService.cancelBooking(bookingId);
return msg;

DTO

@NotBlank(message="{booking.hotelname.invalid}")
hotelName

@NotBlank(message="{booking.vendorname.invalid}")
vendorName
@Min(value=1 , message="{booking.noofrooms.invalid}"
noOfRooms


@ExceptionHandler(Exception.class)

logger.error(ex.getMessage(),ex)
ErrorInfo err =new ErrorInfo();
err.setErrorCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
err.setErrorMsg(environment.getProperty(TrivaInfyConstants.TRIVAINFY_EXCEPTIONMSG_GENERAL.toString()))
return new ResponseEntity<>(err,HttpStatus.INTERNAL_SERVER_ERROR);

@ExceptionHandler(TrivanInfyException.class)

logger.error(ex.getMessage(),ex)
ErrorInfo err =new ErrorInfo();
err.setErrorCode(HttpStatus.BAD_REQUEST.value());
err.setErrorMsg(environment.getProperty(ex.getMessage()))
return new ResponseEntity<>(err,HttpStatus.BAD_REQUEST);


@ExceptionHandler({MethodArgumentNotValid.class,ConstraintViolationException.class})

*****************************************

2.INFYRIDE

APPLICATION PROP

server.port=8080
server.servlet.context-path=/InfyRide

SERVICE

public String bookRide(RideDTO rideDTO) throws InfyRideException{

Fare fare=fareRepository.getPickupLocationIgnoreCaseAndDropLocationIgnoreCase(rideDTO.getPickupLocation(),rideDTO.getDropLocation());
if(fare.isEmpty())
	throw new InfyRideException(InfyRideConstants.INFYRIDE_PICKUPTODROPLOCATION_NOT_FOUND.toString());
Ride ride=RideDTO.prepareRideEntity(fare);
ride.setStatus("BOOKED");
ride.setTotalFare(fare.getFare());
rideRepository.save(ride);
return env.getProperty(InfyRideConstants.INFYRIDE_BOOKING_SUCCESS.toString()+ride.getTotalFare());
}


API

@RestController
@Validated
@RequestMapping

public class api {

@Autowired
private InfyRideService infyRideService;

@GetMapping(value="ride/{pickupLocation}/{dropLocation}")
public String getEstimatedFare(@PathVariable String pickupLocation ,@PathVariable String dropLocation) throws InfyRideException{
return infyRideService.getEstimatedFare(pickupLocation.trim(),dropLocation.trim());
}

@PostingMapping(value="ride")
public String bookRide(@Valid @RequestBody RideDTO rideDTO) throws InfyRideException{
return infyRideService.bookRide(rideDTO);
}

@PutMapping(value="ride/{rideId}/{newPickupLocation}")
public String updateRide(@Min(value=1,message="{ride.rideId.invalid}")@PathVariable String rideId ,@PathVariable String newPickupLocation) throws InfyRideException{
return infyRideService.updateRide(rideId,newPickupLocation);

@DeleteMapping(value="ride/{rideId}")
public String cancelRide(@Min(value=1,message="{ride.rideId.invalid}")@PathVariable String rideId, @Valid @RequestBody CancelBookingDTO cancelBookingDTO) throws InfyRideException{
return infyRideService.cancelRide(rideId,cancelBookingDTO);

DTO

@NotBlank(message="{ride.pickuplocation.notpresent}")
pickupLocation

@NotBlank(message="{ride.droplocation.notpresent}")
dropLocation

@NotNull(message="{ride.ridedatetime.notpresent}")
@PresentOrFuture(message="{ride.ridedatetime.invalid}")
rideDateTime

@NotNull(message="{ride.reasonforcancellation.notpresent}")
@Pattern(regexp="(?=.*[a-zA-Z0-9].*)[a-zA-Z0-9.,!]*)", message="{ride.reasonforcancellation.invalid}"
reasonForCancellation

EXCEPTION

@RestControllerAdvice

@ExceptionHandler(Exception.class)

logger.error(ex.getMessage(),ex)
ErrorInfo err =new ErrorInfo();
err.setErrorCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
err.setErrorMsg(environment.getProperty(InfyRideConstants.INFYRIDE_EXCEPTIONMSG_GENERAL.toString()))
return new ResponseEntity<>(err,HttpStatus.INTERNAL_SERVER_ERROR);


@ExceptionHandler(InfyRideException.class)

logger.error(ex.getMessage(),ex)
ErrorInfo err =new ErrorInfo();
err.setErrorCode(HttpStatus.BAD_REQUEST.value());
err.setErrorMsg(environment.getProperty(ex.getMessage()));
return new ResponseEntity<>(err,HttpStatus.BAD_REQUEST);


@ExceptionHandler({MethodArgumentNotValid.class,ConstraintViolationException.class})

******************************

3.INFYPANDA

APPLICATION PROP

server.port=2222
serever.servlet.context-path=/Infypanda

SERVICE IMPL

publis List<RestaurantDTO>searchRestaurantWithItemName(String ItemName) throw {
List<Item> item=itemRepository.findByItemNameIgnoreCase(itemName);
if(item.isEmpty()){
	throw new InfyPandeException(InfyPandaConstants.INFYPANDA_ITEM_NAME_INVALID.toString());
}
List<RestaurantDTO> DtoList =new ArrayList<>();
List<Restaurant>restaurant1= item.getRestairant();
for(Restaurant restaurant2 :restaurant1){
RestaurantDTO dto=RestaurantDTO.valueOf(restaurant2);
}
DtoList.add(dto);
return DtoList;
}


DTO CLASS 


API CLASS

@RestController
@RequestMapping
@Validated

public class api{

@Autowired
InfyPandaService infyPandaService;

@GetMapping(value="/restaurants/{itemName})
public List<RestaurantDTO>searchRestaurantWithItemName(@PathVariable String ItemName) throw new InfyPandException{

List<RestaurantDTO> res=infyPandaService.searchRestaurantWithItemName(itemName.trim());

return res;
}


@GetMapping(value="/Items/{restaurantName}")
public List<ItemDTo>searchItemsByRestaurantName(@PathVariable String restaurantName) throw new InfyPandException{

List<ItemDTo>item=infyPandaService.searchItemsByRestaurantName(restaurantName.trim());
return item;
}

@PostMapping(value="/order")
public String placeOrder(@Valid @ResponseBody OrderDTO orderDTO)
String order1 =infyPandaService.placeOrder(orderDTO);
return order1;
}

@PutMapping(value="/order/{orderId}/{quantityNew}")
public String updateOrder(@Min(value=1 , message= "{order.orderId.invalid}") @PathVariable Integer orderId,@Min(value=1 , message= "{order.orderId.invalid}") @PathVariable Integer quantityNew)
String update = infyPandaService.updateOrder(orderId, quantityNew);
return update;

@DeleteMapping(value="/order/{orderId}")
public String cancelOrder(@Min(value=1 , message= "{order.orderId.invalid}") @PathVariable orderId)
String del =infyPandaService.cancelOrder(orderId);
return del ;
}

****************************************

4.INFYBANK

APPLICATION PROP

server.port =2222
server.servlet.context-path=/InfyBankBranchService

SERVICEIMPL

public BranchDTO addBranch(BranchDTO branchDTO) throws InfyBankException{
BranchDetailsValidator.validateTimings(branchDto.getOpeningTime(),branchDto.getClosingTime());
List<Branch>branch=branchRepository.findBranchByAddress(branchDTO.getAdress);
if(branch.size()>1){
	throw new InfyBankException("BranchServiceImpl.DUPLICATE_BRANCH");
}
List<Branch>ph =branchRepository.findBranchByMobileNumber(branchDTO.getMobileNumber());
if(ph.size()>1){
	throw new InfyBankException("BranchServiceImpl.PHONENUMBER_ALREADY_EXIT");
}
Branch bran=BranchDTO.dtoTOEntityConverter(branchDTO);
bran.setBranchCode(branchRepository.getBrachCodeMax()+1);
bran.setIfscCode("INFY0000"+bran.getBranchCode());
bran.setEmailId("InfyBank"+bran.getBranchCode()+"@infybank.co.in");
bran.setStatus("ACTIVE");
branchRepository.save(bran);
branchDTO.setBranchCode(bran.getBranchCode());
.
.
 
return branchDTO;
}


API

@RestControllerAdvice

@Validated

@Autowired
BranchService branchService

@PostMapping(value="branch")
public ResponseEntity<BranchDTO> addBranch(@Valid @RequestBody BranchDTO branchDTO) throws InfyBankException{

BranchDTO branchDto=branchService.addBranch(branchDTO);
return new ResponseEntity<>(branchDto)
}

@GetMapping(value="branch/{pinCode}"
public ResponseEntity<List<BranchDTO>> locateBranches(@Pattern(regexp="[0-9]{10}" ,message="{branch.phonenumber.invalid}"
@PathVariable long pinCode) throws InfyBankException{

List<BranchDTO> pin=branchService.locateBranches(pinCode);
return new ResponseEntity<>(pin);
}

@PutMapping(value="branch")
public ResponseEntity<BranchDTO> updateBranch(@Valid @RequestBody BranchUpdateDTO branchUpdateDTO) throws InfyBankException{

branchDTO bran=branchService.updateBranch(branchUpdateDTO);
return new ResponseEntity<>(bran);

}

@DeleteMapping(value="/branch/{branchCode}")
public ResponseEntity<String> deleteBranch(@PathVariable @Pattern(regexp="[0-9]{4}" , message="{branch.code.invalid}")  int branchCode) throws InfyBankException{

String msg=branchService.deleteBranch(branchCode);
return new ResponseEntity<>(msg);


DTO

@NotNull(message="{branch.openingtime.invalid}")
openingtime

@NotNull(message="{branch.openingtime.invalid}")
closedtime

@NotBlank(message="{branch.branchType.notpresent}")
@Pattern(regexp="(Retail|Commercial|Overseas)" , message ="{branch.branchType.invalid}"
branchType

@NotNull(message="{branch.address.invalid}")
Address

@Pattern(regexp="[0-9]{6}" ,message="{branch.pincode.invalid}"
pinCode

@Pattern(regexp="[0-9]{10}" ,message="{branch.phonenumber.invalid}"
pinCode

*****************************************


5.ITICKET

APPLICATION.PROP

server.port=2222
server.servlet.context-path=/ITicket


SERVICEIMPL

public long getMaxEmail(String firstChar) throws TicketException{
List<Ticket>ticket = repo.findAll();
return ticket.stream()
.filter(tick->tick.getEmailId()
		  .startWith(firstChar)
		  .count(); }


API

@RestController
@Validated
public api {
	@Autowired 
	TicketService ticketService;

@PostMapping(value="ticket")
public ResponseEntity<TicketDTO> raiseTicket(@Valid @RequestBody TicketDTO ticketDTO) throws TicketException{
TicketDTO ticketDto=ticketService.raiseTicket(ticketDTO)+ticketDTO.getTicketNumber;
return new ResponseEntity<>(ticketDto,HttpStatus.CREATED);

@GetMapping(value="ticket/{ticketNumber}")
public ResponseEntity<TicketDTO>searchTicket(@Min(value=1000 ,meaasage="{ticket.ticketNumber.invalid}") @Max(value=9999 ,message="{ticket.ticketNumber.invalid}")@PathVariable Integer ticketNumber) throws TicketException{

TicketDTO ticketDto=ticketService.searchTicket(ticketDTO);
return new ResponseEntity<>(ticketDto,HttpStatus.OK);

@GetMapping(value="/emailids/{firstChar}")
public ResponseEntity<Long> getMaxRepaetedEmails(@PathVariable String firstChar) throws TicketException{
Long ticketDto=ticketService.getMaxEmail(firstChar);
return new ResponseEntity<>(ticketDto,HttpStatus.OK);

@GetMapping(value="ticket")
public ResponseEntity<List<TicketDTO>> getReport(@NotNull(message="{ticket.email.notpresent}") @Email(message="{ticket.email.invalid}") @RequestParam("emailId") throws TicketException{

List<TicketDTO>ticketDto=ticketService.getReport(emailId);
return new ResponseEntity<>(ticketDto,HttpStatus.OK);

DTO

@NotNull(message="{ticket.phoennumber.notpresent}")
@Pattern(regexp="[1-9]\\d{9}",message="{ticket.phoennumber.invalid}")
phoneNumber

@NotNull(message="{ticket.email.notpresent}")
@Email(message="{ticket.email.invalid}")
emailId

.
.
.

************************************

6.MORTGAGE

APPLICATION.PROP

server.port=2525
server.servlet.context-path= /mortgage

SERVICEIMPL


public List fetchAllLoansForCustomer(String panNumber) throws MortgageException{
Optional<Customer> optional=customerRepository.findById(panNumber);
optional.orElseThrow(()-> new MortgageException("Service_CustomerNotFound");
List<Loan> loan =loanRepo.findLoanByPanNumber(panNumber);
if(loan.isEmpty()){
throw new MortgageException("Service.No_Loan");
}
List<LoanDTO> loanList=new Array<>();
for(Loan loan1 : loan){
LoanDTO loanDto =new LOanDTO();

loanList.add(LOanDTO.prepareEntity(loan1));
}
return loanList;
}

public Integer applyLoan(LoanDTO loanDTO) throws Ex{
Optional<Customer> optional=customerRepository.findById(panNumber);
optional.orElseThrow(()-> new MortgageException("Service_CustomerNotFound");
Optional<Property>optional1 =propertyRepository.findById(loanDTO.getProperty().getPropertyNumber());
optional1.orElseThrow(()-> new MortgageException("Service.Property_Used");
Loan loan =LoanDTO.prepareEntity(loanDTO);
loan.setEmi(0.0);
Loan saved=loanRepo.save(loan);
return saved.getLoanId();
}

public Loan loanEvaluation(Integer loanId,Double estimatedValue){
Optional<Loan> optional=loanRepository.findById(loanId);
Loan loan=optional.orElseThrow(()-> new MortgageException("Service_LOAN_DOES_NOT_EXIT");
if(!loan.getStatus().equals(LoanStatus.Pending))
	throw new MortgageException("Service_LOAN_CANNOT_UPDATE");
if(loan.getRequiredAmount()>estimatedAmount)
	throw new MortgageException("Service_LOAN_CANNOT_INITIATE");
else{
double principalAmount=loan.getRequiredAmount();
double monthlyInterestRate =INTEREST_RATE/12/100;
int totalMonths=loan.getLoanTenure();
double EMI =Math.round((principalAmount*monthlyInterestRate*Math.pow(1+monthlyInterestRate,totalMonths))/(Math.pow(1+monthlyInterestRate,totalMonths)-1));

List<Loan> loanList=loanRepository.findLoanByCustomerPanNumber(loan.getCustomer().getPanNumber());
if(loanList.size()>1){
double sum=0.0;
for(loan loan1 : loanList){
sum+=l.getEmi();
}
if(loan.getCustomer().getMonthlyIncome()-sum> EMI){
loan.setLoanStatus(LoanStatus.APPROVED);
loan.setLoanAmount(principalIncome);
loan.setEmi(sum);
}
else{
loan.setLoanStatus(LoanStatus.REJECTED);
}
}
else{
if(loan.getCustomer().getMonthlyIncome()>EMI){
loan.setLoanStatus(LoanStatus.APPROVED);
loan.setLoanAmount(principalIncome);
loan.setEmi(EMI);
}
else{
loan.setLoanStatus(LoanStatus.REJECTED);
}
}
if(loan.getStatus().equals(LoanStatus.REJECTED)
	throw new MortgageException("Service_LOAN_IS_REJECTED");
else
	return loanRepositry.save(loanList); }


API

@RestController
@RequestMapping(value="/loan")
@Validated

@PostMapping(value="/register",consumes="application/json")
public ResponseEntity<>customerRegistration(@Valid @ResponseBody CustomerDTO customerDTO) throws MortageException{
Integer id=customerService.regiter(customerDTO);
string msg= environment.getProperty("Customer has been rregisterd successfully with id : ")+getCutomer().getPanNumber();
return new ResponseEntity<>(msg,HttpStatus.CREATED);
}

@GetMapping(value="/{id}/{panNumber}")
public ResponseEntity<List<LoanDTO>>fetchAllLoanForCustomer(@PathVariable @Pattern(regexp="wfbrg" message="{wrwbsrb}") String panNumber) throws MortgageException{
List<LoanDTO>loan=customerService.fetchAllLoanForCustomer(String panNumber);
return new ResponseEntity<>(loan,HttpStatus.CREATED);
}

@PostMapping(value="/applyloan")
public ResponseEntity<Intger> applyLoan(@Valid @ResponseBody Loan loan) throws MortageException{
Integer loanId=customerService.regiter(customerDTO);
string msg= "You have successfully with id : "+loanId;
return new ResponseEntity<>(msg,HttpStatus.CREATED);


}
EXCEPTION

@ExceptionHandler(Exception.class)

ErrorInfo err=new ErorrInfo();
err.errorMg(environament.getProperty("tgvref"));
err.errorCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
return new ResponseEntity<ErrorInfo>(msg,HttpStatus.INTERNAL_SERVER_ERROR)

@ExceptionHandler(Mortgage.class)


ErrorInfo err=new ErorrInfo();
err.errorMg(environament.getProperty("tgvref"));
err.errorCode(HttpStatus.BAD_REQUEST.value());
return new ResponseEntity<ErrorInfo>(msg,HttpStatus.BAD_REQUEST);

@ExceptionHandler({MethodArgumentNotValid.class,ConstantInvalid.class})

**************************************
